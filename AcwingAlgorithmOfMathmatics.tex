\documentclass[]{book}
\usepackage{ctex}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\definecolor{commentgreen}{RGB}{2,112,10}
\definecolor{eminence}{RGB}{108,48,130}
\definecolor{weborange}{RGB}{255,165,0}
\definecolor{frenchplum}{RGB}{129,20,83}


\title{AcWing算法基础、提高课 数学知识}
\author{廖涛}
\date{2022年4月15日}


\begin{document}
\lstset{
    language=C++,
    frame=tb,
    tabsize=4,
    showstringspaces=false,
    numbers=left,
    %upquote=true,
    commentstyle=\color{commentgreen},
    keywordstyle=\color{eminence},
    stringstyle=\color{red},
    basicstyle=\small\ttfamily, % basic font setting
    emph={int,char,double,float,unsigned,void,bool},
    emphstyle={\color{blue}},
    % escapechar=\&,
    % keyword highlighting
    classoffset=1, % starting new class
    otherkeywords={>,<,.,;,-,!,=,~},
    morekeywords={>,<,.,;,-,!,=,~},
    keywordstyle=\color{weborange},
    classoffset=0,
}


\maketitle
\tableofcontents

\chapter{质数}
$\forall n\in [(1, +\infty) \cap Z^+]$，若 n 只有 1 和 n 两个约数，
那么 n 为质数（素数），否则为合数。

0、1以及负整数既不是质数也不是合数。

\section{判定质数}
\begin{lstlisting}
bool is_prime(int n)
{
    if(n < 2) return false;

    for(int i = 2; i <= n / i; i ++)
    {
        if(n % i == 0) return false;
    }
    return true;
}
\end{lstlisting}

1.是否是大于等于2的整数，2. 从 2~n-1 中是否有 n 的约数。

不要写$i*i<n$，可能 $i*i$结果溢出 int；也不要在循环条件里写$i<=sqrt(n)$,
否则每次循环都会调用$sqrt()$。

$d \mid n$，则必有$\frac{n}{d} \mid n$，故不需要枚举到 $n - 1$，即枚举每组
约数的最小值即可。

时间复杂度为$O(\sqrt{n})$

\section{分解质因数}
\begin{lstlisting}
void divide(int n)
{
    for(int i = 2; i <= n / i; i ++)
    {   
        int cnt = 0;
        if(n % i == 0)
        {
            while(n % i == 0)
            {
                n /= i;
                cnt ++;
            }
            printf("%d %d\n", i, cnt);
        }
        
    }
    
    if(n > 1) printf("%d 1\n", n);
    puts("");
}
\end{lstlisting}

从 2 开始枚举到$\sqrt{n}$，每找到一个质因子则将 n 中的该质因子除尽，最后判断n是否
大于 1，若大于1，则此时的 n 也是所求质因子之一。

Tips1：所有合数因子在被枚举到之前会被更小的质数因子除尽。故枚举到的合数必定不会满足$n \bmod i = 0$。
eg：$n = 24$，8 这个合数因子必然会被之前出现的 2 除尽（除3次）。

Tips2：n 最多只存在 1 个大于等于$\sqrt{n}$的质因子，故只需要枚举到$\sqrt{n}$再
判断最后的 n 情况如何即可。简单证明，假设存在
\[ a \mid n, b \mid n, a>\sqrt{n}, b>\sqrt{n}\]
前两个条件可得$a \times b \mid n$，最后一个条件可得$a \times b > n$，相悖，故假设不成立，故 n 最多只存在
1 个大于等于$ \sqrt{n}$ 的质因子。

Tips3：当 $n = 2^k$ 时，第一次枚举即能把 n 除尽，此时的时间复杂度为 $\log_{2}{n}$，
最坏情况则是需要枚举到$\sqrt{n}$，故该方法的时间复杂度为为 $O(\log_{2}{n})$与$O(\sqrt{n})$之间。
\section{质数筛}
\subsection{埃氏筛法}
\begin{lstlisting}
void get_primes(int n)
{
    for(int i = 2; i <= n; i ++)
    {
        if(st[i]) continue;
        
        primes[cnt ++] = i;
        for(int j = 2 * i; j <= n; j += i)
        {
            st[j] = true;
        }
    }
}
\end{lstlisting}

从 2 枚举到 n，即能找到 n 以内的所有质数。每次枚举到的 i 若 st[i] 为 false 则说明 i 为质数，记录到 primes[]中，
并筛掉其倍数。否则 i 为合数，直接跳过本次循环。

这里说明为什么不需要用合数筛掉其他数，当 st[i]为 true 时证明之前已经找到了 i 的一个或多个质因子，
i 的倍数也必定是这些质因子的倍数，所以当 i 为合数时，i 的倍数已经在之前被其质因子筛掉，不需要再筛。

在枚举到 i 时，$2 ~ i-1$的所有数都已经枚举过，若 st[i] 为 false 则说明 $2 ~ i-1$均不是 i 的因数，则 i 为质数（素数），否则为合数。

时间复杂度分析，当$i=2$时内层循环次数为$\frac{n}{2}$，当$i=3$时为$\frac{n}{3}$...，这里我们假设合数也进行内层循环，则内层循环的次数和为
\[\frac{n}{2} + \frac{n}{3} + \frac{n}{4} + \cdots + \frac{n}{n} = n \times (\frac{1}{2} + \frac{1}{3} + \frac{1}{4} + \cdots + \frac{1}{n})\]
调和级数
\[\lim_{n \to \infty} \frac{1}{2} + \frac{1}{3} + \frac{1}{4} + \cdots + \frac{1}{n} = \ln_{}{n}\]
故内层循环的次数小于等于$n\ln_{}{n}$小于$nlog_{2}{n}$，故可以认为埃氏筛法的时间复杂度为
\[O(n\log_{2}{n})\]

\subsection{欧拉筛法(线形筛法)}

\begin{lstlisting}
void get_primes(int n)
{
    for(int i = 2; i <= n; i ++)
    {
        if(!st[i]) primes[cnt ++] = i;
        
        for(int j = 0; primes[j] <= n / i; j ++)
        {
            st[primes[j] * i] = true;
            if(i % primes[j] == 0) break;
        }
    }
}
\end{lstlisting}

欧拉筛法的一个特点之一就是每个合数都是用其最小的质因子筛掉。

这里重点讲内层循环。首先无论 i 是否为质数，都会进内层循环。$primes[]$ 中小的数一定在前面。

当 $i \bmod primes[j] != 0$ 时，$primes[j]$ 的不是 i 的因子，则$primes[j] * i$的最小质因子就是$primes[j]$。

当 $i \bmod primes[j] == 0$ 时， $primes[j]$ 是 i 的最小质因子，也是$primes[j] * i$的最小质因子。但当 j ++ 后，
$primes[j + 1] * i$ 有更小的质因子 $primes[j]$（$primes[j] \mid i$）这里就不满足用最小质因子筛去合数的要求，所以要break。

\chapter{约数}
\section{试除法求约数}
\begin{lstlisting}
vector<int> get_divisors(int x)
{
vector<int> res;
for(int i = 1; i <= x / i; i ++)
{
    if(x % i == 0)
    {
        res.push_back(i);
        if(i * i != x) res.push_back(x / i);
    }
}
sort(res.begin(), res.end());
return res;
}
\end{lstlisting}
\section{约数个数}
若 
\[n = p_{1}^{a_{1}} + p_{2}^{a_{2}} + p_{3}^{a_{3}} +\cdots+ p_{n}^{a_{n}}\]
那么 n 的约数个数为
\[(a_{1} + 1) * (a_{2} + 1) * (a_{3} + 1) *\cdots* (a_{n} + 1)\]
\begin{lstlisting}
#include <iostream>
#include <algorithm>
#include <unordered_map>

using namespace std;

const int N = 110, mod = 1e9 + 7;
typedef long long LL;

int main()
{
    int n;
    cin >> n;
    unordered_map<int, int> primes;
    
    while(n --)
    {
        int x;
        cin >> x;
        for(int i = 2; i <= x / i; i ++)
        {
            while(x % i == 0)
            {
                x /= i;
                primes[i] ++;
            }
        }
        if(x > 1) primes[x] ++;
    }
    
    LL res = 1;
    for(auto t : primes)
    {
        LL p = t.first, s = t.second;
        res = res * (s + 1) % mod;
    }
    
    cout << res << endl;
    
    return 0;
}
\end{lstlisting}
\section{约数之和}
若
\[n = p_{1}^{a_{1}} + p_{2}^{a_{2}} + p_{3}^{a_{3}} +\cdots+ p_{n}^{a_{n}}\]
那么 n 的约数之和为
\[(p_{1}^{0} + p_{1}^{1} + \cdots + p_{1}^{a_{1}}) * (p_{2}^{0} + p_{2}^{1} + \cdots + p_{2}^{a_{2}}) * (p_{3}^{0} + p_{3}^{1} + \cdots + p_{3}^{a_{3}}) * (p_{n}^{0} + p_{n}^{1} + \cdots + p_{n}^{a_{n}})\]
\section{最大公约数}
$(a / \gcd(a, b)) * (b / \gcd(a, b))* \gcd(a, b)$ 即$a / \gcd(a, b) * b$为 a和b 的最小公倍数。
\begin{lstlisting}
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
\end{lstlisting}
\chapter{欧拉函数}
n的欧拉函数为$[1,\quad n - 1]$内与 n 互质的数的个数。\\
若 
\[n = p_{1}^{a_{1}} + p_{2}^{a_{2}} + p_{3}^{a_{3}} +\cdots + p_{n}^{a_{n}}\]
那么
\[\phi(n) = n * (1 - \frac{1}{p_{1}}) * (1 - \frac{1}{p_{2}}) *\cdots* (1 - \frac{1}{p_{n}}) = 
n*(\frac{p_{1} - 1}{p_{1}})*(\frac{p_{2} - 1}{p_{2}})*\cdots *(\frac{p_{n} - 1}{p_{n}})\]
当 n 为质数时
\[\phi(n) = n - 1\]

\section{费马小定理}
若 a 为整数，p 为质数，那么
\[a^{\phi(p)}\equiv 1 \pmod{p}\]\\即
\[a^{p-1}\equiv 1 \pmod{p}\]
\chapter{快速幂}
\section{快速幂原理}
\begin{lstlisting}
LL qmi(LL a, LL b, LL p)
{
LL res = 1;
while(b)
{
    if(b & 1) res = res * a % p;
    a = a * a % p;
    b >>= 1;
}
return res;
}
\end{lstlisting}
\section{快速幂求逆元}
当模数 p 为质数时，a 的逆元即为 $a^{p-2}$，故直接用快速幂计算即可。
\begin{lstlisting}
qmi(a, p - 2, p);
\end{lstlisting}
\chapter{扩展欧几里得算法（粉碎机）}
\section{扩展欧几里得算法原理}
\section{扩展欧几里得算法求逆元}

\chapter{中国剩余定理（孙子定理）}

\chapter{组合数}

\chapter{容斥原理}

\chapter{博弈论}
\end{document}